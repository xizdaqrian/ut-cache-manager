#!/usr/bin/python3
#
# ut-cache-mgr-2
# By Rodney Fisk <xizdaqrian@gmail.com>
# Adapted from ut-cache-manager
# by:
# ------------------------------------------------------------------------
# Martin Tournoij <martin@arp242.net>
# http://carpetsmoker.net/weblog/Manage_Unreal_Tournament_cache_files.php
# Free to use for whatever purpose. There are no restrictions.
# Version 20100624
#
# This is a very simple script to manage unreal tournament cache files.
# Works on Windows, FreeBSD, Linux.
# ------------------------------------------------------------------------
# Thank you Martin

# Imports
import getopt
import os
import re           # REGEX
import shutil
import sys
import time


# http://stackoverflow.com/questions/287871/print-in-terminal-with-colors-using-python
# http://stackoverflow.com/questions/4842424/list-of-ansi-color-escape-sequences
class bcolors:
    ''' A set of colors for printing '''

    # Foreground Standard
    RED = '\033[31m'
    BLUE = '\033[34m'
    CYAN = '\033[36m'
    ENDC = '\033[0m'
    WHITE = '\033[37m'
    GREEN = '\033[32m'
    BLACK = '\033[30m'
    YELLOW = '\033[33m'
    MAGENTA = '\033[35m'

    # Foreground Bold
    bRED = '\033[31;1m'
    bBLUE = '\033[34;1m'
    bCYAN = '\033[36;1m'
    bWHITE = '\033[37;1m'
    bGREEN = '\033[32;1m'
    bBLACK = '\033[30;1m'
    bYELLOW = '\033[33;1m'
    bMAGENTA = '\033[35;1m'

    # Background Standard
    RED_BACK = '\033[41m'
    BLUE_BACK = '\033[44m'
    CYAN_BACK = '\033[46m'
    WHITE_BACK = '\033[47m'
    GREEN_BACK = '\033[42m'
    BLACK_BACK = '\033[40m'
    YELLOW_BACK = '\033[43m'
    MAGENTA_BACK = '\033[45m'


def read_config():
    '''reads dotfile named after the invocation name of the script'''
    rc_file = '%s/.%src' % (user_home, this_name)
    config_pairs = {}

    if not os.path.exists(rc_file):
        return 1

    print('Using settings found in %s' % rc_file)

    with open(rc_file, 'r') as rc_:
        for line in rc_:
            if not line.startswith(('[', '# ', '\0', '\n')) and not line == '':
                line = line.strip()
                (key, val) = line.split('=')
                key = key.strip()
                val = val.strip()
                config_pairs[key] = val

    for k_key, v_val in config_pairs.items():
        # Can't be [0-9]. It must be a "tuple of string"
        if not v_val.startswith(tuple(str(range(10)))):
            # globals()[k] = v[1:-1]
            globals()[k_key] = v_val
        else:
            globals()[k_key] = int(v_val)

    return 0


def write_config(argv):
    ''' Write a default set of values when creating a new config file '''
    # config = configparser.ConfigParser()
    rc_name = '%s/.%src' % (user_home, this_name)

    Paths = {'game_folder': 'Games/Epic/UT2004/',
             'cache_folder': 'Games/Epic/UT2004/Cache/'}
    Files = {'ini_file': 'cache.ini',
             'cache_extension': 'uxx'}
    Options = {'color_output': '0',
               'pause_output': '0',
               'show_missing': '0'}
    try:
        # By accessing locals(), we get the complete list of local variables.
        # This way we don't have to change anything below, after editing the
        # dictionaries above. We have to make a copy, which is static
        # locals() changes when we iterate over it
        locals_ = locals().copy()
        with open(rc_name, 'w') as config_file:
            for i in locals_.keys():
                # Is the word "dict" in the type output?
                if str(type(locals()[i])).find('dict') != -1:
                    section_line = '[' + i + ']\n'
                    config_file.write(section_line)
                    for k_key, v_val in eval(i).items():
                        kv_pair_line = k_key + '=' + v_val + '\n'
                        config_file.write(kv_pair_line)
                        config_file.write('\n')
        config_file.close()

        print('Config file written to %s' % rc_name)
        exit(0)
    except IOError as err:
        print(err)
        exit(1)


# http://stackoverflow.com/questions/566746/how-to-get-console-window-width-in-python
def get_terminal_size():
    ''' Get terminial size in lines and columns. Helper for pausing output \
            every screenful '''
    env = os.environ

    def ioctl_gwinsz(file_descr):
        try:
            import fcntl
            import termios
            import struct
            rows_cols = struct.unpack('hh',
                                      fcntl.ioctl(file_desrows_cols,
                                                  termios.TIOCGWINSZ,
                                                  '1234'))
        except Exception:
            return
        return rows_cols
    rows_cols = ioctl_gwinsz(0) or ioctl_gwinsz(1) or ioctl_gwinsz(2)
    if not rows_cols:
        try:
            file_desrows_cols = os.open(os.ctermid(), os.O_RDONLY)
            rows_cols = ioctl_gwinsz(file_desrows_cols)
            os.close(file_desrows_cols)
        except Exception:
            pass
    if not rows_cols:
        rows_cols = (env.get('LINES', 25), env.get('COLUMNS', 80))

        # # # Use get(key[, default]) instead of a try/catch
        # try:
        #    rows_cols = (env['LINES'], env['COLUMNS'])
        # except:
        #    rows_cols = (25, 80)
    return int(rows_cols[1]), int(rows_cols[0])


def print_ver():
    ''' Print the current file version of this script '''
    print ("UT-Cache-Manager - Python Version 0.46")
    sys.exit(0)


def print_help():
    ''' Print a complete help screen '''
    print ("%s " % str(sys.argv[0]) + "[-v] [-h] [-l] [-p] [-c] path/to/cache [-x] REGEX")
    sys.exit(0)


def exists_ini_file():
    ''' Check to see if a cache.ini or equivalent exists in supplied path '''
    try:
        cache_folder
    except NameError:
        print ('==>ERROR: The Cache _folder has not been specified')
        print_help()
        sys.exit(1)

    try:
        ini_file
    except NameError:
        print ('==>ERROR: The INI _filename has not been specified')
        print_help()
        sys.exit(1)

    ini = os.path.join(str(cache_folder), ini_file)
    if not os.path.exists(ini):
        print ('Error: file "%s" does not exist.' % ini_file)
        print ('Example: %s -c C:\\games\\UnrealTournament\\Cache\\ -f cache.ini' % sys.argv[0])
        sys.exit(1)


def read_file(filename, regex):
    ''' Read the ini file supplied and parse it '''
    move = []
    with open(filename, 'r') as file_name:
        for line in file_name:
            if line[0] == ';' or line[0] == '[':
                continue

            line = line.strip()
            if line == '':
                continue

            l = line.split('=')
            # http://www.tutorialspoint.com/python/python_reg_expressions.htm
            # Make regex case insensitive and make ^|$ match beg. & end of line
            uxx = str(l[0]) + '.uxx'
            l.insert(1, uxx)
            del l[0]
            if os.path.exists('%s/%s' % (cache_folder, l[0])):
                uxx_ctime = time.strftime("%m-%d-%Y", time.gmtime(os.stat('%s/%s' % (cache_folder, l[0])).st_ctime))
            else:
                uxx_ctime = 'Not Found'

            l.insert(0, uxx_ctime)

            search_obj_date = re.search(regex, l[0], re.M | re.I)
            search_obj_name = re.search(regex, l[2], re.M | re.I)
            if search_obj_date or search_obj_name:
                move.append(l)

    file_name.close()
    return move


def search(regex):
    ''' Search for, & display, objects specified in command line arguments '''
    missing = []
    counter = 1
    (width, height) = get_terminal_size()

    exists_ini_file()
    move = read_file(os.path.join(cache_folder, ini_file), regex)

    for file in move:
        uxx_ctime = file[0]
        uxx_file = file[1]
        true_file = file[2]
        if file[0] != 'Not Found':
            # http://www.seanelavelle.com/2012/05/04/make-os-stat-times-readable-in-python/
            if color_output == 1:
                print (bcolors.GREEN + "%s\t" % uxx_ctime + bcolors.bBLACK + "%s\t" % uxx_file + bcolors.ENDC +  "%s" % true_file)
            else:
                print ("%s\t%s\t%s" % (uxx_ctime, uxx_file, true_file))
        else:
            if color_output == 1 and show_missing == 1:
                print (bcolors.bRED + "%s\t" % uxx_ctime + bcolors.bBLACK + "%s\t" % uxx_file + bcolors.ENDC + "%s" % true_file)
            elif color_output != 1 and show_missing == 1:
                print ("%s\t%s\t%s" % (uxx_ctime, uxx_file, true_file))
            missing.append(file)

        counter += 1
        if counter == (height - 3) and pause_output == 1:
            # pause at each screenful
            os.system("read -n 1 -p \"Press any key to continue\n\" ")
            counter = 0

    print ("Entries decoded:\t" + bcolors.CYAN + "%4i" % len(move) + bcolors.ENDC)
    print ("Missing files\t\t" + bcolors.bRED + "%4i" % len(missing) + bcolors.ENDC)
    print ("Extractable files:\t" + bcolors.GREEN + "%4i" % (len(move) - len(missing)) + bcolors.ENDC)
    if show_missing != 1:
        print ("Show missing results with the \'-m\' option")

    exit(0)


def extract(regex):
    ''' Copy the files to destfolder and rename them to truename '''
    missing = []
    exists_ini_file()
    move = read_file(os.path.join(cache_folder, ini_file), regex)

    if not dest_folder:
        print('==>ERROR:  Please specify a destination folder')
        print_help()

    if not os.path.exists(dest_folder):
        print("_folder %s not found. Creating %s now..." % (dest_folder, dest_folder))
        try:
            os.makedirs(dest_folder)
        except os.error as err:
            print(err)
            exit(1)

    for file_spec in move:
        if file_spec[0] == 'Not Found':
            missing.append(file_spec)
            continue

        src = '%s/%s' % (cache_folder, file_spec[1])
        dst = '%s/%s' % (dest_folder, file_spec[2])

        try:
            shutil.copy2(src, dst)
            print('extracting ' + bcolors.bBLACK + '%s' % file_spec[1] + bcolors.ENDC + ' ==> ' + bcolors.GREEN + '%s' % dst + bcolors.ENDC)
        except shutil.Error as err:
            print(err)
            exit(1)

    print ("Entries decoded:\t" + bcolors.CYAN + "%4i" % len(move) + bcolors.ENDC)
    print ("_missing files\t\t" + bcolors.bRED + "%4i" % len(missing) + bcolors.ENDC)
    print ("Extracted _files:\t" + bcolors.GREEN + "%4i" % (len(move) - len(missing)) + bcolors.ENDC)
    exit(0)


def main(argv):
    ''' This is where the magic happens '''
    # Globals
    global cache_extension
    global cache_folder
    global color_output
    global dest_folder
    global game_folder
    global ini_file
    global osPlatform
    global pause_output
    global show_missing
    global this_name
    global user_home

    user_home = os.path.expanduser('~')
    this_name = os.path.basename(sys.argv[0])
#   os_platform = sys.platform

    if read_config() != 0:
        print('No config file found... using defaults and options')
        cache_extension = 'uxx'
        color_output = 0
        ini_file = 'cache.ini'
        pause_output = 0
        show_missing = 0
        # listofArgs = str(sys.argv)
        # if sys.platform[:3] == 'win':
        #   cache_folder = '%s\\UnrealTournament\\Cache\\' % os.getenv('SYSTEMDRIVE')
        # else:
        #     cache_folder = os.path.expanduser('~/.loki/ut/Cache/')

    # Command line arguments with getopt
    try:
        # Short option syntax: "hv:"
        # Long option syntax: "help" or "verbose="
        opts, args = getopt.getopt(sys.argv[1:], "hvpmlrb:d:f:c:d:x:",
                                   ['help', 'version', 'pause', 'show-missing',
                                    'colorize', 'make-rc', 'cache-file',
                                    'cache-folder', 'dest-folder', 'extract'])

    except getopt.GetoptError as err:
        # Print debug info
        print (err)

    for option, argument in opts:
        if option in ("-h", "--help"):
            print_help()
        elif option in ("-v", "--version"):
            print_ver()
        elif option in ("-p", "--pause"):
            pause_output = 1
        elif option in ("-m", "--show-missing"):
            show_missing = 1
        elif option in ("-l", "--colorize"):
            color_output = 1
        elif option in ('-r', '--make-rc'):
            write_config(sys.argv)
        elif option in ("-c", "--cache-folder"):
            cache_folder = argument
        elif option in ("-d", "--dest-folder"):
            dest_folder = argument
        elif option in ("-x", "--extract"):
            extract(argument)
        # else:
            # exit(0)

    num_args = len(sys.argv)
    if num_args == 1:
        print_help()

    search(sys.argv[-1])
    pass

if __name__ == "__main__":
    main(sys.argv)

# -----------------------------------------------------------------------------
# Task List
# -----------------------------------------------------------------------------
# TODO: Get argparse working for cl arguments
# FIXME: Improve help screen
# TODO: Add toggle for summary information

# -----------------------------------------------------------------------------
# Version History
# -----------------------------------------------------------------------------
# 0.47  2014-12-14    +Corrected all style issues to be compliant w/PEP-8
# 0.46  2014-11-30    +Totally re-wrote the writeconfig routine.
#                     + because configparser sucks
# 0.45  2014-11-30    +Now reads _and_ writes config file
# 0.40  2014-11-29    +Now checks for, and reads config file, if present
#                     +Added main() function & moved everything in there
#                     +Declared variables are overridden by switches
# 0.30  2014-11-28    +Extract now working
# 0.20  2014-11-28    +Dates into list
#                     +Files searchable by date
# 0.17  2014-11-26    +Enabled toggle to show/hide missing entries
#                     +Enabled toggleable colorization
# 0.16  2014-11-25    +Implemented REGEX search(Use single dot for everything)
# 0.15  2014-11-25    +Fixed pause function.
#                     +Enabled command line options
# 0.10  2014-11-24    +Disabled all moving or copying functions
#                     +Added colorization to output (not yet toggleable)
#                     +Added timestamp, changed behavior for missing files
#                     +Cleaned up output to be more readable

# vim: set ts=4 sw=4 tw=4 sts=4 et :
